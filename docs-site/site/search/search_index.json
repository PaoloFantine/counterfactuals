{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#run-the-api","title":"Run the API","text":"<p>Ensure demo artifacts exist:</p> <pre><code># For classification\npython -m src.model_training.classification_training\n</code></pre> <pre><code># For regression\npython -m src.model_training.regression_training\n</code></pre> <p>then start the API locally:</p> <pre><code>uv run uvicorn api.main:app --reload\n</code></pre> <p>or simply run the helper script that ensures the artifacts exist, creates them if they don't and starts the API locally:</p> <pre><code>bash API_start.sh\n</code></pre> <p>Once the API is running, visit http://127.0.0.1:8000/docs for auto-generated API docs.</p> <p>There are two routers in the API:</p> <ul> <li><code>/regression/</code> for regression models </li> <li><code>/classification/</code> for classification models</li> </ul> Endpoint Method Description <code>/model_info/</code> GET Info about the model and dataset <code>/report/</code> GET Training metrics summary <code>/counterfactuals</code> POST Generate counterfactuals for a given instance <p>See the swagger docs for full request/response schemas.</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#getting-started","title":"Getting started","text":"<ol> <li>Clone the repo:</li> </ol> <pre><code>git clone git@github.com:PaoloFantine/counterfactuals.git\ncd counterfactuals\n</code></pre> <p>Dependencies are managed using uv.</p> <p>The <code>pyproject.toml</code> contains all the needed dependencies. For development and runnning the code, using a virtual environment is recommended.</p> <p>So one should install uv (Linux example: <code>curl -LsSf https://astral.sh/uv/install.sh | sh</code>)</p> <ol> <li>Create the virtual environment and activate it:</li> </ol> <pre><code>uv venv .venv\nsource .venv/bin/activate\n</code></pre> <ol> <li>Create the uv.lock and install the necessary dependencies:</li> </ol> <pre><code>uv lock\nuv sync --locked --active\n</code></pre> <ol> <li>Check out the demo at <code>./notebooks/basic_demo.ipynb</code> or a more high-level overview in the docs</li> </ol>"},{"location":"overview/","title":"Counterfactuals for Machine Learning Models","text":"<p>Interpreting Machine Learning (ML) models is not always straightforward. You might wonder: Why did the model give this specific response? </p> <p>Some models, like linear regression or decision trees, are inherently interpretable \u2014 you can see how each feature affects the outcome. But many ML models capture complex, nonlinear relationships. For most users, the key question is not just why, but how could the outcome be changed?</p> <p>Imagine a few scenarios:</p> <ul> <li>A loan application is rejected. The applicant wants to know what they could change to get approval.  </li> <li>A health screening predicts a high risk factor. A patient wants to know actionable steps to improve their health outcome.  </li> <li>A data scientist wants to ensure the model is fair and aligns with business rules.</li> </ul> <p>Counterfactuals provide answers to these questions.  </p> <p>A counterfactual is the answer to: \"What changes to the features would result in a different, desired outcome?\"</p>"},{"location":"overview/#example","title":"Example","text":"<p>Suppose a simple loan application model predicts whether a loan will be approved (1) or denied (0).  </p> Feature Original Applicant Counterfactual Suggestion Age 25 25 Annual Income $30,000 $45,000 Credit Score 600 650 Loan Approved? 0 1 <p>Figure 1: Original applicant vs counterfactual suggestion.</p> <p>In this case, the counterfactual shows that the model would approve the loan if the applicant increased their income to $45,000 and improved their credit score to 650. Notice that the age does not need to change \u2014 the counterfactual only modifies the features that influence the outcome.</p> <p>This repository provides Python tools to generate such counterfactual explanations:</p> <ul> <li>Giving transparency into how ML models work.</li> <li>Helping consumers take actionable steps.</li> <li>Supporting auditing for fairness and compliance.</li> </ul>"},{"location":"structure/","title":"Project Structure","text":""},{"location":"structure/#project-structure","title":"Project Structure","text":"<pre><code>.\n|-api/ # Code to run the API\n|-artifacts/ # Artifacts needed for the demos\n|-notebooks/ # notebooks demonstrating how to generate counterfactuals\n|-src/ # main code repository\n|--cf_code/ # code to generate counterfactuals\n|--data_loader/ # code to load the demo data from scikit-learn\n|--model_training/ # code to train demo classification and regression models\n|--pydantic_models/ # models for the API\n|-API_start.sh # script to generate demo artifacts and start the API\n|-pyproject.toml # file listing the necessary dependencies of the package\n|-README.md # this file - describing the features of the package\n|-uv.lock # project dependencies\n</code></pre>"},{"location":"usage/","title":"Using the library","text":"<p>Assuming you already have data split in <code>X</code> a pandas dataframe containing predictor variables and <code>y</code> a pandas series containing the outcomes of the rows in <code>X</code>, using the library is rather easy.</p> <p>In general, <code>X</code> is used only to determine existing distributions and data types, and, in the case of prototypes, to search for existing solutions so there is no fear of data leakage and the data could be the training data or a larger set if needed.</p> <p>A model is also needed. The code has been developed with <code>scikit-learn</code> in mind, so, as long as a model has methods <code>.fit</code>, <code>.predict</code> and, in the case of classification, <code>predict_proba</code>, it should work easily.</p> <p>We just need to initialize a counterfactuals class:</p> <pre><code>from src import Counterfactuals\n\ncf = Counterfactuals(X=X, y=y, model=model)\n</code></pre> <p>We should then have an instance for which a counterfactual is desired. Say we want to take it from <code>X</code>:</p> <pre><code>instance = X.iloc[0:1].copy\n</code></pre> <p>but it could be taken by any dataframe, as long as it contains the columns <code>X</code> contains.</p> <p>Now, generating a counterfactual only requires a single call. There is a slight difference depending on whether Prototypes or genetic counterfactuals are needed.</p>"},{"location":"usage/#prototypes","title":"Prototypes","text":"<p>For prototypes, an instance in <code>X</code> is searched that has the desired outcome and is close in feature space to the <code>instance</code> we pass:</p> <pre><code>prototypes = cf.get_counterfactuals(instance, \n                                    n_counterfactuals=5, \n                                    method=\"prototypes\", \n                                    desired_class=1)\n</code></pre> <p>We just need to specify how many counterexamples we want and what outcome class we want.</p> <p>Sometimes though, a counterfactual will suggest changing features we cannot change (like our age, sex or height). This would point to a bias in the model probably, but we can get around this by fixing some feature values:</p> <pre><code>cf.get_counterfactuals(instance, \n                       n_counterfactuals=5, \n                       method=\"prototypes\", \n                       desired_class=1, \n                       fix_vars=['relationship', 'race'])\n</code></pre> <p>Where, in this case, we fixed features 'relationship' and 'race' from the <code>adult</code> dataset.</p> <p>It may happen that not enough counterfactuals exist in the data. All the more if we restrict the search field by fixing some feature values. In that case, <code>get_counterfactuals</code> will only return as many as it finds in the existing data.</p>"},{"location":"usage/#genetic-algorithm","title":"Genetic algorithm","text":"<p>For genetic counterfactuals, existence of the solution is not a problem as they are made to generate solutions and return the fittest ones.  The call is very similar, we just need to specify the different method:</p> <pre><code>cf.get_counterfactuals(instance, \n                       n_counterfactuals=5, \n                       method=\"genetic\", \n                       desired_class=1, \n                       fix_vars=['relationship', 'race'])\n</code></pre> <p>Genetic counterfactuals are based on mutating existing data though. Seems straightforward, but some care needs to be taken whenever one-hot encoded features exist. A mutation could make those two-, three- or n-hot encoded, which, in most cases, would not even mean anything. This is also accounted for by adding the prefix of one-hot encoded variables to ensure co-mutation:</p> <pre><code>cf.get_counterfactuals(instance, \n                       n_counterfactuals=5, \n                       method=\"genetic\", \n                       desired_class=1, \n                       fix_vars=['relationship', 'race'], \n                       one_hot_encoded = ['sex_'])\n</code></pre>"},{"location":"usage/#regression-counterfactuals","title":"Regression counterfactuals","text":"<p>Finally, for regression problems, we might need an interval of outcome values or, at the very list, a lower or upper bound. In this case, we would need to specify at least one of <code>lower_limit</code>, <code>upper_limit</code>, the code automatically recognizes classification or regression models:</p> <pre><code>cf.get_counterfactuals(instance, \n                       n_counterfactuals=3, \n                       method='prototypes', \n                       upper_limit=4, \n                       lower_limit=3)\n</code></pre> <p>Obviously, what was said in the classification case about choosing the method, fixing variables values and specifying one-hot encoded feature prefixes holds for regression as well.</p>"}]}